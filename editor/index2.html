<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>TileMaster - Sheet Prep</title>
    <link rel="stylesheet" type="text/css" href="./css/main2.css">
	
	
	<script src="https://cdn.babylonjs.com/babylon.worker.js"></script>

	
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div class='pane' id='start' name='Select Image'>
	<center><input type='file' id='in-image'></input></center>
</div>

<div class='pane' id='tools' name='Settings' style='display:none;'>
	<div class='in'><span>Sheet-Name</span><input id='name'></input></div>
	<div class='in'><span>Tile-Size</span><input id='size' type='number' value='32' min='1'></input></div>
	<div class='in'><span>Zoom</span><input id='zoom' value='1' type='number'  min='0.01' max='16'></input></div>
</div>

<div class='pane' id='preview' name='Preview' style='display:none;'>
	<center><canvas id="previewCanvas"></canvas></center>
</div>


<script>

function buildScene(iDat){
	var canvas = document.getElementById('renderCanvas');
	var engine = new BABYLON.Engine(canvas, true);		  
		var scene = new BABYLON.Scene(engine);
			scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.82);
			var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -10), scene);
			camera.setTarget(BABYLON.Vector3.Zero());			
			var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
			light.intensity = .5;

var _vs =
`precision highp float;
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
// Uniforms
uniform mat4 worldViewProjection;

uniform vec2 viewOffset;
uniform vec2 viewportSize;
uniform vec2 sheetSize;

varying vec3 vPosition;
varying vec2 vUV;
varying vec2 pixelCoord;


void main() {
    vec4 p = vec4( position, 1. );    
	vPosition = p.xyz;
	
	gl_Position = worldViewProjection * p;	
	vUV = uv;
	vUV.y = 1.0 - vUV.y;
	
	pixelCoord = (vUV * viewportSize) + viewOffset;
	
	
	
}`;
var _fs =
`uniform vec2 viewOffset;
uniform vec2 viewportSize;
uniform sampler2D sprite;
uniform vec2 sheetSize;
uniform vec2 mousePos;
uniform float tileSize;
uniform vec2 selectedTile;

varying vec3 vPosition;
varying vec2 vUV;
varying vec2 pixelCoord;



void main(){
	vec2 sCoord = pixelCoord/sheetSize;
	if(sCoord.x < 0.  || sCoord.x > 1. || sCoord.y < 0.  || sCoord.y > 1. ){discard;}	
	vec4 cSample = texture2D(sprite, sCoord);	
	vec3 color = cSample.xyz;
	float alpha = cSample.a;
	
	float tileHS = tileSize*0.5;
	
	vec2 tID = floor(pixelCoord/tileSize);
	vec2 mPos = floor(mousePos/tileSize);
	
	vec3 cursorColor = vec3(1.0, 0.5, 1.0);
	vec3 selectedColor = vec3(0.0, 1.0, 1.0);
	
	if(tID == selectedTile){
			color = mix(color, selectedColor, 0.65);
			if(alpha == 0.0){alpha = 1.0;}
	}else{
		if(tID == mPos){
			color = mix(color, cursorColor, 0.65);
			if(alpha == 0.0){alpha = 1.0;}
		}
	}
	
		
	if(alpha == 0.){discard;}
	
	gl_FragColor =  vec4(color, alpha);
}
`;
	BABYLON.Effect.ShadersStore["editorVertexShader"] = _vs;
	BABYLON.Effect.ShadersStore["editorFragmentShader"] = _fs;	
	
	var texture = new BABYLON.DynamicTexture('sheet', {width:iDat.width, height:iDat.height}, scene, false, 1);
	var ctx = texture._context;
	ctx.putImageData(iDat, 0, 0);
	texture.update(false);

	var defines = [];
		defines.push('precision highp float;');
		
		var shader = new BABYLON.ShaderMaterial("basicShader", scene, {
			vertex: "editor",
			fragment: "editor",
			},{
			attributes: ["position", "normal", "uv"],
			defines: defines,
			samplers: ['sprite'],
			uniforms: ["world",
			"worldView", 
			"worldViewProjection",
			"view", "viewOffset",
			"viewportSize", "sheetSize", "mousePos", "selectedTile"]
			});	
	
	var offset = new BABYLON.Vector2(0, 0);
	var zoom = 1.0;
	var tileSize = 32.0;
	
	function resizeShader(){
		shader.setVector2('viewportSize', new BABYLON.Vector2(canvas.width/zoom, canvas.height/zoom));
		shader.setVector2('viewOffset', offset);
	}
	function setMousePos(pos){
	shader.setVector2('mousePos', pos.divide(new BABYLON.Vector2(zoom, zoom)));
	}
	function setTileSize(){
		shader.setFloat('tileSize', tileSize);
	}
	function selectTile(id){
		shader.setVector2('selectedTile', id);
	}
	function setShaderDefaults(){
		resizeShader();
		setMousePos(new BABYLON.Vector2(0, 0));
		selectTile(new BABYLON.Vector2(-1, -1));
		setTileSize();
		shader.setTexture('sprite', texture);
		shader.setVector2('sheetSize', new BABYLON.Vector2(texture._texture._width, texture._texture._height));
	}			
			setShaderDefaults();
			console.log(shader);
			
	var mesh;
	
	function buildMesh(){
		if(mesh){mesh.dispose();}
		var c = scene.activeCamera;
		var fov = c.fov;
		var aspectRatio = engine.getAspectRatio(c);
		var d = c.position.length();
		var y = 2 * d * Math.tan(fov / 2);
		var x = y * aspectRatio;		
		mesh = BABYLON.MeshBuilder.CreatePlane("output-plane", {width: x, height:y}, scene);
		mesh.material = shader;
	};
	
	
	var zoomIn = document.getElementById('zoom');
	var sizeIn = document.getElementById('size');
	
	
	var keys = {};
	
	document.body.addEventListener('keydown', function(e){
		keys[e.code] = true;
		console.log(e.code);
	}, false);
	
	document.body.addEventListener('keyup', function(e){
		keys[e.code] = false;
	}, false);
	
	
	document.body.addEventListener('mousemove', function(e){
			setMousePos((new BABYLON.Vector2(e.clientX, e.clientY)).add(offset));
	}, false);
	
	document.body.addEventListener('click', function(e){
			var id = (new BABYLON.Vector2(e.clientX, e.clientY)).add(offset);
			var size = tileSize*zoom;
			id.x = Math.floor(id.x/size);
			id.y = Math.floor(id.y/size);
			selectTile(id);			
	}, false);
	
	engine.runRenderLoop(function () {
			scene.render();
	});
	
	window.addEventListener("resize", function () {
		engine.resize();
		resizeShader();
		buildMesh();
	}); 
	
	zoomIn.addEventListener('change', function(e){
			zoom = e.target.value;
			resizeShader();
	}, false);
	
	sizeIn.addEventListener('change', function(e){
			tileSize = e.target.value;
			setTileSize();
	}, false);
	
	scene.registerBeforeRender(()=>{
	 if(keys['ArrowLeft']){offset.x+=1;}
	 if(keys['ArrowRight']){offset.x-=1;}
	 if(keys['ArrowUp']){offset.y+=1;}
	 if(keys['ArrowDown']){offset.y-=1;}
	});
	
	
	buildMesh();
};


document.addEventListener("DOMContentLoaded", () => {
	var input = document.getElementById('in-image');
	var start = document.getElementById('start');
	var tools = document.getElementById('tools');
	var name = document.getElementById('name');
	var preview = document.getElementById('preview');
	
	input.addEventListener("change", (e)=>{
		var file = input.files[0];
		var fr = new FileReader();
		var img = new Image();
		var cvas = document.createElement('canvas');
		
		img.onload =(e)=>{
			console.log(e.target);
			cvas.width = e.target.width;
			cvas.height = e.target.height;
			var ctx = cvas.getContext('2d');
			ctx.drawImage(img,0,0);
			var iDat = ctx.getImageData(0,0,cvas.width, cvas.height);
			start.style = "display:none;";
			tools.style = "";
			preview.style = "";
			name.value = file.name;
			buildScene(iDat);
		} 
		
		fr.onload =(e)=>{
			console.log(e);
			img.src = fr.result;
		}  // onload fires after reading is complete
			
		
		fr.readAsDataURL(file);		
	}, false);

},false);

</script>	

	
</body>
</html>